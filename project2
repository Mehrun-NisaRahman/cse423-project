from OpenGL.GL import *
from OpenGL.GLUT import *
from OpenGL.GLU import *
import random
import os

# ----------------------------
# Camera / View
# ----------------------------
camera_position = (0, 500, 500)
fovY = 120
grid_length = 100           # cell size
grid_size = 14              # grid cells per side

# ----------------------------
# Game State / Player
# ----------------------------
playerPos = [0, 0, 0]       # x,y,z (bike anchored to z=0)
playerAngle = 0             # forward-facing along -Y in our world
camMode = "third"
gameStatus = False          # True -> GAME OVER

# Reused containers
pickups = []                # repurposed as pickups (coins/fuel)
rocks = []                # repurposed as traffic + rocks
numRocks = 2

# Player stats
life = 3                 # 3 lives (Traffic Rider)
score = 0
coins = 0
fuel = 100.0                # 0..100
distance_covered = 0.0

# Arena bounds (visual only; barriers on left/right)
minBoundary = -grid_size * grid_length // 2
maxBoundary = grid_size * grid_length // 2

# "cheat" repurposed as "boost"
boost = False

# ----------------------------
# Endless Runner Parameters
# ----------------------------
lanes = [-120, 0, 120]      # three lanes (x positions)
lane_index = 1              # start in middle
base_speed = 1.0            # world scroll speed
speed = base_speed
difficulty = 1.0
paused = False
started = False             # main menu
day_timer = 0.0             # for day/night cycle (seconds)
DAY_CYCLE_SECONDS = 10.0     # 10 secs day + 10 secs night
# SHOW_MILESTONE_EVERY = 0.5  # meters
# SHOW_MILESTONE_AT = 0.5   # 0.5 meters = 50 cm
# milestone_reached = False

# last_milestone = 0.0
# leaderboard_file = "lead.txt"
# --- Milestones (every 0.5 m = 50 cm) ---
SHOW_MILESTONE_EVERY = 0.1   # meters
POPUP_DURATION = 1.2         # seconds the popup stays visible
popup_timer = 0.0            # countdown in seconds
next_milestone = SHOW_MILESTONE_EVERY
last_milestone = 0.0         # last milestone hit (meters)


# ----------------------------
# Text & HUD
# ----------------------------
def draw_text(x, y, text, font = GLUT_BITMAP_HELVETICA_18):
    glColor3f(1,1,1)
    glMatrixMode(GL_PROJECTION)
    glPushMatrix()
    glLoadIdentity()
    gluOrtho2D(0, 1000, 0, 600)
    glMatrixMode(GL_MODELVIEW)
    glPushMatrix()
    glLoadIdentity()
    glRasterPos2f(x, y)
    for ch in text:
        glutBitmapCharacter(font, ord(ch))
    glPopMatrix()
    glMatrixMode(GL_PROJECTION)
    glPopMatrix()
    glMatrixMode(GL_MODELVIEW)

# ----------------------------
# World: Road, Barriers, Sky
# ----------------------------
def drawFloor(GRID_SIZE):
    # Centered checker to suggest asphalt + lane stripes
    glBegin(GL_QUADS)
    for i in range(GRID_SIZE):
        for j in range(GRID_SIZE):
            # asphalt color
            glColor3f(0.12, 0.12, 0.12)
            x = (i - GRID_SIZE // 2) * grid_length
            y = (j - GRID_SIZE // 2) * grid_length
            glVertex3f(x, y, 0)
            glVertex3f(x + grid_length, y, 0)
            glVertex3f(x + grid_length, y + grid_length, 0)
            glVertex3f(x, y + grid_length, 0)
    glEnd()

    # lane stripes (dashed)
    glColor3f(1.0, 1.0, 0.3)
    for lx in lanes[:-1]:
        x = (lx + lanes[lanes.index(lx)+1]) / 2.0
        glBegin(GL_LINES)
        for j in range(-GRID_SIZE//2, GRID_SIZE//2):
            if j % 2 == 0:
                glVertex3f(x, j * grid_length, 1)
                glVertex3f(x, j * grid_length + grid_length*0.6, 1)
        glEnd()

def drawWalls():
    # Left/Right barriers (simple long walls)
    wall_ref = grid_length * grid_size // 2
    wallHeight = 30
    # left barrier
    glColor3f(0.7, 0.5, 0.95)
    glBegin(GL_QUADS)
    glVertex3f(lanes[0] - 80, -wall_ref, 0)
    glVertex3f(lanes[0] - 80, wall_ref, 0)
    glVertex3f(lanes[0] - 80, wall_ref, wallHeight)
    glVertex3f(lanes[0] - 80, -wall_ref, wallHeight)
    glEnd()
    # right barrier
    glBegin(GL_QUADS)
    glVertex3f(lanes[-1] + 80, -wall_ref, 0)
    glVertex3f(lanes[-1] + 80, wall_ref, 0)
    glVertex3f(lanes[-1] + 80, wall_ref, wallHeight)
    glVertex3f(lanes[-1] + 80, -wall_ref, wallHeight)
    glEnd()

# ----------------------------
# Player (Bike)
# ----------------------------
# ----------------------------
# Player (Bike + Rider)
# ----------------------------
fallen = False   # new state for player fall

def drawBikeWithRider():
    # global fallen
    glPushMatrix()
    # snap player to lane X; Y fixed near bottom
    playerPos[0] = lanes[lane_index]
    playerPos[1] = -250
    playerPos[2] = 0
    glTranslatef(*playerPos)

    # If game over, fall sideways
    if fallen:
        glRotatef(90, 0, 1, 0)

    # ----- Bike Base -----
    # Frame
    glColor3f(0.2, 0.2, 0.8)
    glPushMatrix()
    glScalef(1.2, 2.5, 0.2)
    glutSolidCube(20)
    glPopMatrix()

    # Wheels
    glColor3f(0,0,0)
    # Front wheel
    glPushMatrix()
    glTranslatef(0, 22, -5)
    glRotatef(90, 0,1,0)
    gluCylinder(gluNewQuadric(), 8, 8, 4, 20, 2)
    glPopMatrix()
    # Rear wheel
    glPushMatrix()
    glTranslatef(0, -22, -5)
    glRotatef(90, 0,1,0)
    gluCylinder(gluNewQuadric(), 8, 8, 4, 20, 2)
    glPopMatrix()

    # Handlebar
    glColor3f(0.7,0.7,0.7)
    glPushMatrix()
    glTranslatef(0, 26, 10)
    glScalef(0.3, 2.0, 0.3)
    glutSolidCube(12)
    glPopMatrix()

    # Seat
    glColor3f(0.3,0.3,0.3)
    glPushMatrix()
    glTranslatef(0, -5, 10)
    glScalef(1.0, 0.5, 0.3)
    glutSolidCube(18)
    glPopMatrix()

    # ----- Rider (simple humanoid) -----
    # Torso
    glColor3f(1,0.8,0.6)
    glPushMatrix()
    glTranslatef(0, 0, 25)
    glScalef(0.5, 1.2, 1.0)
    glutSolidCube(15)
    glPopMatrix()

    # Head
    glColor3f(1,0.8,0.6)
    glPushMatrix()
    glTranslatef(0, 0, 40)
    gluSphere(gluNewQuadric(), 8, 16, 16)
    glPopMatrix()

    # Arms
    glColor3f(1,0.8,0.6)
    glPushMatrix()
    glTranslatef(10, 5, 30)
    glScalef(0.3, 1.0, 0.3)
    glutSolidCube(12)
    glPopMatrix()
    glPushMatrix()
    glTranslatef(-10, 5, 30)
    glScalef(0.3, 1.0, 0.3)
    glutSolidCube(12)
    glPopMatrix()

    # Legs
    glColor3f(0,0,1)
    glPushMatrix()
    glTranslatef(5, -10, 10)
    glScalef(0.3, 1.2, 0.3)
    glutSolidCube(12)
    glPopMatrix()
    glPushMatrix()
    glTranslatef(-5, -10, 10)
    glScalef(0.3, 1.2, 0.3)
    glutSolidCube(12)
    glPopMatrix()

    glPopMatrix()
# ----------------------------
# Pickups (Coins & Fuel) using `bullets`
# bullets: {'pickup_pos':[x,y,z], 'dir':(0,-1), 'type':'coin'/'fuel'}
# ----------------------------
def drawPickups():
    for i in pickups:
        glPushMatrix()
        glTranslatef(*i['pickup_pos'])
        # if i.get('type') == 'fuel':
        #     glColor3f(1, 0, 0)
        #     glutSolidCube(15)
        if i.get('type') == 'fuel':
            glColor3f(1, 0, 0)  # bright red fuel can
            glPushMatrix()
            glScalef(0.8, 1.2, 1.0)  # squish like a can
            glutSolidCube(15)        # main body
            glPopMatrix()

            # Handle on top
            glColor3f(0.8, 0.8, 0.8)  # gray handle
            glPushMatrix()
            glTranslatef(0, 0, 10)    # top
            glScalef(0.3, 0.8, 0.2)
            glutSolidCube(15)
            glPopMatrix()

        else:
            glColor3f(1, 0.84, 0)  # coin
            gluSphere(gluNewQuadric(), 9, 12, 12)
        glPopMatrix()

# ----------------------------
# Traffic / Rocks using `enemies`
# enemy: {'rock_pos':[x,y,0], 'kind':'car'/'rock', 'scale':1.0}
# ----------------------------
def drawTrafficOrObstacles(e):
    glPushMatrix()
    glTranslatef(*e['rock_pos'])
    if e.get('kind') == 'rock':
        glColor3f(0.5, 0.5, 0.5)
        glScalef(1.0, 1.0, 0.8)
        glutSolidCube(40)
    # else:
    #     # car
    #     glScalef(1.0, 2.0, 0.8)
    #     glColor3f(1, 0, 0)
    #     glutSolidCube(40)
    #     glColor3f(0,0,0)
    #     glTranslatef(0, 20, -12)
    #     glScalef(1.0, 0.4, 0.6)
    #     glutSolidCube(40)
    glPopMatrix()

def generateRockPosition():
    # Spawn ahead at random lane, far positive Y, with random kind
    lane = random.choice(lanes)
    y = random.randint(300, 1200)
    return {
        'rock_pos': [lane, y, 0],
        'scale': 1.0,
        'scale_dir': 0.0,
        'kind': "rock",
        'collide': False
    }

# initial rocks
for n in range(numRocks):
    rocks.append(generateRockPosition())

# ----------------------------
# Input: mouse for "settings" area, special keys for movement/speed
# ----------------------------
def mouseListener(button, state, x, y):
    global camMode, paused, started, gameStatus
    # invert y to bottom-left origin
    y = 600 - y
    if button == GLUT_LEFT_BUTTON and state == GLUT_DOWN:
        # Top-left settings "buttons" (simple hit-boxes)
        if 10 <= x <= 90 and 520 <= y <= 590:
            # Pause/Play
            if started and not gameStatus:
                paused = not paused
        elif 100 <= x <= 180 and 520 <= y <= 590:
            # Restart
            if started:
                do_restart()
        elif 190 <= x <= 270 and 520 <= y <= 590:
            # Exit
            os._exit(0)
        elif 280 <= x <= 360 and 520 <= y <= 590:
            # Cam toggle
            camMode = "first" if camMode == "third" else "third"
        else:
            # click anywhere on main menu to start
            if not started:
                started = True
                paused = False
                gameStatus = False

    elif button == GLUT_RIGHT_BUTTON and state == GLUT_DOWN and not gameStatus:
        # spare: toggle camera mode
        camMode = "first" if camMode == "third" else "third"
        glutPostRedisplay()

def keyboardListener(key, x, y):
    global camMode, boost, paused, started
    # Keep WASD no-ops to preserve old compatibility
    if key == b'p':
        if started and not gameStatus:
            paused = not paused
    if key == b'c':
        # repurpose cheat as BOOST toggle
        boost = not boost
    if key == b'r':
        do_restart()
    if key == b'\x1b':  # ESC
        os._exit(0)

def specialKeyListener(key, x, y):
    global lane_index, speed
    if not started or paused or gameStatus:
        return
    if key == GLUT_KEY_RIGHT:
        lane_index = min(lane_index + 1, len(lanes)-1)
    if key == GLUT_KEY_LEFT:
        lane_index = max(lane_index - 1, 0)
    if key == GLUT_KEY_UP:
        speed += 1.5
    if key == GLUT_KEY_DOWN:
        speed = max(4.0, speed - 1.5)

# ----------------------------
# Camera
# ----------------------------
def setupCamera():
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(fovY, 1.25, 0.1, 3000)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()

    if camMode == "third":
        # chase cam behind and above bike
        x = lanes[lane_index]
        y = -450
        z = 220
        gluLookAt(x, y, z, x, y+200, 0, 0, 0, 1)
    else:
        # first person near handlebar
        x = lanes[lane_index]
        y = -220
        z = 40
        gluLookAt(x, y, z, x, y+200, z, 0, 0, 1)

# ----------------------------
# Collisions and movement
# ----------------------------
# def checkCollision():
#     global life, gameStatus, rocks
#     if gameStatus or not started or paused:
#         return
#     px, py, pz = lanes[lane_index], -250, 0
#     # AABB-ish check per entity
#     new_list = []
#     for e in rocks:
#         ex, ey, ez = e["rock_pos"]
#         hit = abs(px - ex) < 30 and abs(py - ey) < 40
#         if hit:
#             if e.get('kind') == 'rock':
#                 # instant game over
#                 life = 0
#                 game_over()
#                 return
#             else:
#                 # car hit: lose a life, respawn car
#                 life -= 1
#                 if life <= 0:
#                     game_over()
#                     return
#                 # respawn this car further ahead
#                 new_list.append(generateRockPosition())
#         else:
#             new_list.append(e)
#     rocks[:] = new_list
def checkCollision():
    global life, gameStatus, rocks
    if gameStatus or not started or paused:
        return
    px, py, pz = lanes[lane_index], -250, 0
    # AABB-ish check per entity
    new_list = []
    for e in rocks:
        ex, ey, ez = e["rock_pos"]
        hit = abs(px - ex) < 30 and abs(py - ey) < 40
        if hit:
            # Any collision (rock or car) â†’ lose one life
            life -= 1
            if life <= 0:
                game_over()
                return
            # respawn this obstacle further ahead
            new_list.append(generateRockPosition())
        else:
            new_list.append(e)
    rocks[:] = new_list


def movePickup():
    # repurposed to move PICKUPS (coins/fuel) towards player and recycle
    if not started or paused or gameStatus:
        return
    global pickups
    b = 0
    while b < len(pickups):
        item = pickups[b]
        item['pickup_pos'][1] -= speed * difficulty * 0.9
        x, y, z = item['pickup_pos']
        if y < -700:
            pickups.pop(b)
        else:
            b += 1

def collect_pickups():
    # repurposed to collect pickups
    global pickups, coins, fuel
    if not started or paused or gameStatus:
        return
    px, py, pz = lanes[lane_index], -250, 0
    keep = []
    for i in pickups:
        bx, by, bz = i['pickup_pos']
        if abs(px - bx) < 28 and abs(py - by) < 28:
            if i.get('type') == 'fuel':
                fuel = min(100.0, fuel + 35.0)
            else:
                coins += 1
        else:
            keep.append(i)
    pickups[:] = keep

def boost_mode():
    # repurposed as nitro boost visual/state (no new rendering here)
    global speed
    if boost and started and not paused and not gameStatus:
        speed = min(base_speed * 2.2, speed + 0.4)
    else:
        # gradually relax to current base speed
        target = base_speed + (difficulty - 1.0) * 3.0
        if speed > target:
            speed -= 0.2
        else:
            speed += 0.05

# ----------------------------
# Helpers inside allowed funcs
# ----------------------------
def spawn_coins_and_fuel():
    # probabilistic spawn while running
    if random.random() < 0.005:
        lane = random.choice(lanes)
        y = random.randint(350, 900)
        pickups.append({'pickup_pos':[lane, y, 5], 'dir':(0,-1), 'type':'coin'})
    if random.random() < 0.0009:
        lane = random.choice(lanes)
        y = random.randint(450, 1000)
        pickups.append({'pickup_pos':[lane, y, 5], 'dir':(0,-1), 'type':'fuel'})

def progress_day_night(dt):
    global day_timer
    day_timer = (day_timer + dt) % (2*DAY_CYCLE_SECONDS)
    if day_timer < DAY_CYCLE_SECONDS:
        t = day_timer / DAY_CYCLE_SECONDS
        # daytime sky
        r = 0.25 + 0.2 * t
        g = 0.45 + 0.25 * t
        b = 0.8  + 0.15 * t
    else:
        t = (day_timer - DAY_CYCLE_SECONDS) / DAY_CYCLE_SECONDS
        # night fade
        r = 0.45 - 0.3 * t
        g = 0.7  - 0.45 * t
        b = 0.95 - 0.55 * t
    glClearColor(r, g, b, 1.0)

def do_restart():
    global pickups, rocks, boost, camMode, score, life, gameStatus
    global playerPos, playerAngle, coins, fuel, speed, distance_covered, difficulty
    global paused, started, last_milestone, popup_timer, next_milestone  # NEW
    # milestone_reached = False
    pickups.clear()
    rocks.clear()
    for _ in range(numRocks):
        rocks.append(generateRockPosition())
    boost = False
    camMode = "third"
    score = 0
    coins = 0
    fuel = 100.0
    distance_covered = 0.0
    difficulty = 1.0
    speed = base_speed
    life = 3
    gameStatus = False
    playerPos[:] = [0, 0, 0]
    playerAngle = 0
    paused = False
    started = True
    last_milestone = 0.0
    popup_timer = 0.0          # NEW
    next_milestone = SHOW_MILESTONE_EVERY  # NEW
    glutPostRedisplay()

def game_over():
    global gameStatus, rocks, pickups, fallen
    gameStatus = True
    fallen = True   # make player fall
    rocks.clear()
    pickups.clear()
    # write to leaderboard
    # try:
    #     with open(leaderboard_file, "a") as f:
    #         f.write(f"{score},{coins}\n")
    # except:
    #     pass

# ----------------------------
# Idle loop
# ----------------------------
# prev_time = None
# def idle():
#     global rocks, distance_covered, score, difficulty, fuel, prev_time, last_milestone
#     # frame timing
#     t = glutGet(GLUT_ELAPSED_TIME) / 1000.0
#     if prev_time is None:
#         prev_time = t
#     dt = max(0.0, min(0.05, t - prev_time))
#     prev_time = t
import time

prev_time = None
def idle():
    global rocks, distance_covered, score, difficulty, fuel, prev_time
    global last_milestone, popup_timer, next_milestone  # NEW
    # frame timing
    t = time.perf_counter()
    if prev_time is None:
        prev_time = t
    dt = max(0.0, min(0.05, t - prev_time))
    prev_time = t


    if not started or paused or gameStatus:
        boost_mode()
        glutPostRedisplay()
        return

    # day/night coloring
    progress_day_night(dt)

    # move traffic toward player and recycle when passed
    world_speed = speed * difficulty
    for e in rocks:
        e['rock_pos'][1] -= world_speed
    # recycle offscreen
    rocks[:] = [e for e in rocks if e['rock_pos'][1] > -700] + \
                 [generateRockPosition() for _ in range(max(0, numRocks - len(rocks)))]

    # spawn + move pickups
    spawn_coins_and_fuel()
    movePickup()        # moves pickups
    collect_pickups()    # collect pickups

    # collisions with cars/rocks
    checkCollision()

    # advance distance/score/difficulty/fuel
    distance_covered += world_speed * dt * 3.0   # scale to "meters"
    score = int(distance_covered // 1)
    difficulty = 1.0 + min(3.0, distance_covered / 500)  # ramps up over time
    fuel -= (0.8 + 0.2 * difficulty) * dt       # consumption
    if fuel <= 0:
        fuel = 0
        game_over()

    # milestones every 0.5 m
    # if distance_covered - last_milestone >= SHOW_MILESTONE_EVERY:
    #     last_milestone = distance_covered
    # milestones check
    # if not milestone_reached and distance_covered >= SHOW_MILESTONE_AT and started and not paused and not gameStatus:
    #      milestone_reached = True
    
    # --- Milestones every 0.5 m (50 cm) with popup ---
    # Use a while in case we skip over multiple 0.5 m steps in a single frame
    while distance_covered >= next_milestone and not gameStatus:
        last_milestone = next_milestone
        next_milestone += SHOW_MILESTONE_EVERY
        popup_timer = POPUP_DURATION  # (re)show popup

    # countdown popup timer
    if popup_timer > 0.0:
        popup_timer = max(0.0, popup_timer - dt)


    boost_mode()
    glutPostRedisplay()

# ----------------------------
# Rendering
# ----------------------------
def showScreen():
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    glLoadIdentity()
    glViewport(0, 0, 1000, 700)

    setupCamera()

    # Road + barriers
    drawFloor(grid_size)
    drawWalls()

    # Entities
    drawBikeWithRider()
    for e in rocks:
        drawTrafficOrObstacles(e)
    drawPickups()

    # # HUD / UI
    # # Settings buttons (top-left): [Pause][Restart][Exit][Cam]
    # draw_text(15, 560, "[Pause]")
    # draw_text(105, 560, "[Restart]")
    # draw_text(195, 560, "[Exit]")
    # draw_text(285, 560, "[Cam]")

    # # Top-right stats
    # draw_text(760, 560, f"Score: {score}")
    # draw_text(760, 540, f"Coins: {coins}")
    # draw_text(760, 520, f"Lives: {life}")
    # # draw_text(760, 500, f"Fuel: {int(fuel)}%")

    # Milestone popup (simple)
    # if milestone_reached:
    #     draw_text(420, 520, "ðŸŽ‰ Milestone reached: 50 cm! ðŸŽ‰")

    if popup_timer > 0.0:
        # Format nicely in cm for sub-1m, otherwise meters with one decimal
        if last_milestone < 1.0:
            txt = f"ðŸŽ‰ Milestone: {int(last_milestone * 100)} cm!"
        else:
            txt = f"ðŸŽ‰ Milestone: {last_milestone:.1f} m!"
        draw_text(360, 560, txt)

    # if last_milestone > 0 and (distance_covered - last_milestone) < 150:
    #     draw_text(420, 560, f"Checkpoint: {int(last_milestone/1000)}.{int(last_milestone%1000/100)} km")
    if not gameStatus:
        draw_text(10, 460, f"coins collected: {coins} ")
        draw_text(10, 440, f"Game Score: {score}")
        draw_text(10, 420, f"Life: {life}")
        draw_text(760, 500, f"Fuel: {int(fuel)}%")

    elif not started:
        draw_text(320, 360, "TRAFFIC RIDER")
        # draw_text(290, 320, "Click to Play | [Leaderboard after Game Over]")
        # draw_text(200, 280, "Controls: â† â†’ lanes | â†‘ boost | â†“ slow | [Pause] button or 'P'")
        # draw_text(280, 240, "First/Third Cam: [Cam] button or Right-Click")
    elif paused and not gameStatus:
        draw_text(440, 360, "PAUSED")
        draw_text(320, 320, "Click [Pause] or press 'P' to resume")
    elif gameStatus:
        # show leaderboard
        draw_text(400, 400, "GAME OVER")
        draw_text(360, 370, f"Your Score: {score}   Coins: {coins}")
        # # read top 5
        # try:
        #     entries = []
        #     if os.path.exists(leaderboard_file):
        #         with open(leaderboard_file, "r") as f:
        #             for line in f:
        #                 line=line.strip()
        #                 if not line: continue
        #                 s,c = line.split(",")
        #                 entries.append((int(s), int(c)))
        #         entries.sort(key=lambda x: x[0], reverse=True)
        #     draw_text(410, 330, "LEADERBOARD")
        #     y = 300
        #     for i, (s,c) in enumerate(entries[:5], start=1):
        #         draw_text(380, y, f"{i:>2}. Score {s:>6}  Coins {c:>3}")
        #         y -= 24
        # except:
        #     draw_text(380, 330, "LEADERBOARD unavailable (file error).")
        draw_text(330, 120, "Press 'R' or click [Restart] to play again")

    glutSwapBuffers()

# ----------------------------
# Bootstrap
# ----------------------------
def main():
    glutInit()
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH)
    glutInitWindowSize(1000, 600)
    glutInitWindowPosition(250, 0)
    glutCreateWindow(b"Traffic Rider - OpenGL")
    glEnable(GL_DEPTH_TEST)

    # pleasant initial sky
    glClearColor(0.3, 0.6, 0.9, 1.0)

    glutDisplayFunc(showScreen)
    glutKeyboardFunc(keyboardListener)
    glutSpecialFunc(specialKeyListener)
    glutMouseFunc(mouseListener)
    glutIdleFunc(idle)

    glutMainLoop()

if __name__ == "__main__":
    main()
